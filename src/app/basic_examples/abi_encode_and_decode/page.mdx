export const metadata = {
  title: "ABI Encode/Decode and hashing with keccak256 â€¢ Stylus by Example",
  description:
    "A simple solidity ABI encode and decode example",
};

{/* Begin Content */}

# ABI Encode/Decode and hashing with keccak256

## Encode

The `ABI Encode` has 2 types which are `encode` and `encode_packed`. 

- `encode`  will concatenate all values and add padding to fit into 32 bytes for each values.
- `encode_packed` will concatenate all values in the exact byte representations without padding. (For example, `encode_packed("a", "bc") == encode_packed("ab", "c")`)

Suppose we have a tuple of values: `(target, value, func, data, timestamp)` to encode, and their `alloy primitives type` are `(Address, U256, String, Bytes, U256)`.

Firstly we need to import those types we need from `alloy_primitives`, `stylus_sdk::abi` and `alloc::string`:

```rust
// Import items from the SDK. The prelude contains common traits and macros.
use stylus_sdk::{alloy_primitives::{U256, Address, FixedBytes}, abi::Bytes, prelude::*};
// Import String from alloc
use alloc::string::String;
```

Secondly because we will use the method `abi_encode_sequence` and `abi_encode_packed` under `alloy_sol_types` to encode data, we also need to import the types from `alloy_sol_types`:

```rust
// Becauce the naming of alloy_primitives and alloy_sol_types is the same, so we need to re-name the types in alloy_sol_types
use alloy_sol_types::{sol_data::{Address as SOLAddress, String as SOLString, Bytes as SOLBytes, *}, SolType};
```

Then `encode` them:
```rust
// define sol types tuple
type TxIdHashType = (SOLAddress, Uint<256>, SOLString, SOLBytes, Uint<256>);
// set the tuple
let tx_hash_data = (target, value, func, data, timestamp);
// encode the tuple
let tx_hash_bytes = TxIdHashType::abi_encode_sequence(&tx_hash_data);
```

Or `encode_packed` them:
```rust
// define sol types tuple
type TxIdHashType = (SOLAddress, Uint<256>, SOLString, SOLBytes, Uint<256>);
// set the tuple
let tx_hash_data = (target, value, func, data, timestamp);
// encode the tuple
let tx_hash_data_encode_packed = TxIdHashType::abi_encode_packed(&tx_hash_data);
```

We can also use the following method to `encode_packed` them:
```rust
let tx_hash_data_encode_packed = [&target.to_vec(), &value.to_be_bytes_vec(), func.as_bytes(), &data.to_vec(), &timestamp.to_be_bytes_vec()].concat();
```

## Decode

The `decode` can not be used for `encode_packed` data because it ignores padding when encode.

So here the example is only for `decode` the `abi_encode_sequence` data:

```rust
// This should always return true
pub fn encode_and_decode(
    &self, 
    target: Address,
    value: U256,
    func: String,
    data: Bytes,
    timestamp: U256
) -> Result<bool, HasherError> {
    // define sol types tuple
    type TxIdHashType = (SOLAddress, Uint<256>, SOLString, SOLBytes, Uint<256>);
    // because the abi_encode_sequence will return alloy_primitives::Bytes rather than stylus_sdk::bytes, so we need to make sure the input and return types are the same
    let primative_data = alloy_primitives::Bytes::copy_from_slice(&data);
    // set the tuple
    let tx_hash_data = (target, value, func, primative_data, timestamp);
    // encode the tuple
    let tx_hash_data_encode = TxIdHashType::abi_encode_sequence(&tx_hash_data);

    let validate = true;
    
    // Check the result
    match TxIdHashType::abi_decode_sequence(&tx_hash_data_encode, validate) {
        Ok(res) => Ok(res == tx_hash_data),
        Err(_) => {
            return Err(HasherError::DecodedFailed(DecodedFailed{}));
        },
    }   
}
```

## Hashing with keccak256

Example:
```rust
fn keccak256(&self, data: Bytes) -> FixedBytes<32> {
        // Prepare 
        let mut hasher = Keccak256::new();
        hasher.update(data);
        // Get function selector
        let result = hasher.finalize();
        // convert the hash to FixedBytes<32>
        let result_vec = result.to_vec();
        FixedBytes::<32>::from_slice(&result_vec)   
    }
```

# Full Example code:

### src/main.rs

```rust
#![no_main]
#![no_std]
extern crate alloc;

/// Use an efficient WASM allocator.
#[global_allocator]
static ALLOC: mini_alloc::MiniAlloc = mini_alloc::MiniAlloc::INIT;

/// Import items from the SDK. The prelude contains common traits and macros.
use stylus_sdk::{alloy_primitives::{U256, Address, FixedBytes}, abi::Bytes, prelude::*};
use alloc::string::String;
use alloc::vec::Vec;
// Becauce the naming of alloy_primitives and alloy_sol_types is the same, so we need to re-name the types in alloy_sol_types
use alloy_sol_types::{sol_data::{Address as SOLAddress, String as SOLString, Bytes as SOLBytes, *}, SolType};
use alloy_sol_types::sol;
use sha3::{Digest, Keccak256};

// Define error
sol! {
    error DecodedFailed();
}

// Error types for the MultiSig contract
#[derive(SolidityError)]
pub enum HasherError{
    DecodedFailed(DecodedFailed)
}

// Define some persistent storage using the Solidity ABI.
// `Hasher` will be the entrypoint.
sol_storage! {
    #[entrypoint]
    pub struct Hasher {
    }
}

impl Hasher {
    fn keccak256(&self, data: Bytes) -> FixedBytes<32> {
        // prepare hasher
        let mut hasher = Keccak256::new();
        // populate the data
        hasher.update(data);
        // hashing with keccack256
        let result = hasher.finalize();
        // convert the result hash to FixedBytes<32>
        let result_vec = result.to_vec();
        FixedBytes::<32>::from_slice(&result_vec)   
    }
}

/// Declare that `Hasher` is a contract with the following external methods.
#[external]
impl Hasher {
    
    // Encode the data and hash it
    pub fn encode_and_hash(
        &self, 
        target: Address,
        value: U256,
        func: String,
        data: Bytes,
        timestamp: U256
    ) -> FixedBytes<32> {
        // define sol types tuple
        type TxIdHashType = (SOLAddress, Uint<256>, SOLString, SOLBytes, Uint<256>);
        // set the tuple
        let tx_hash_data = (target, value, func, data, timestamp);
        // encode the tuple
        let tx_hash_data_encode = TxIdHashType::abi_encode_sequence(&tx_hash_data);
        // hash the encoded data
        self.keccak256(tx_hash_data_encode.into())
    }

    // This should always return true
    pub fn encode_and_decode(
        &self, 
        target: Address,
        value: U256,
        func: String,
        data: Bytes,
        timestamp: U256
    ) -> Result<bool, HasherError> {
        // define sol types tuple
        type TxIdHashType = (SOLAddress, Uint<256>, SOLString, SOLBytes, Uint<256>);
        // because the abi_encode_sequence will return alloy_primitives::Bytes rather than stylus_sdk::bytes, so we need to make sure the input and return types are the same
        let primative_data = alloy_primitives::Bytes::copy_from_slice(&data);
        // set the tuple
        let tx_hash_data = (target, value, func, primative_data, timestamp);
        // encode the tuple
        let tx_hash_data_encode = TxIdHashType::abi_encode_sequence(&tx_hash_data);

        let validate = true;
        
        // Check the result
        match TxIdHashType::abi_decode_sequence(&tx_hash_data_encode, validate) {
            Ok(res) => Ok(res == tx_hash_data),
            Err(_) => {
                return Err(HasherError::DecodedFailed(DecodedFailed{}));
            },
        }   
    }
        
    // Packed encode the data and hash it, the same result with the following one
    pub fn packed_encode_and_hash_1(
        &self, 
        target: Address,
        value: U256,
        func: String,
        data: Bytes,
        timestamp: U256
    )-> FixedBytes<32> {
        // define sol types tuple
        type TxIdHashType = (SOLAddress, Uint<256>, SOLString, SOLBytes, Uint<256>);
        // set the tuple
        let tx_hash_data = (target, value, func, data, timestamp);
        // encode the tuple
        let tx_hash_data_encode_packed = TxIdHashType::abi_encode_packed(&tx_hash_data);
        // hash the encoded data
        self.keccak256(tx_hash_data_encode_packed.into())
    }

    // Packed encode the data and hash it, the same result with the above one
    pub fn packed_encode_and_hash_2(
        &self, 
        target: Address,
        value: U256,
        func: String,
        data: Bytes,
        timestamp: U256
    )-> FixedBytes<32> {
        // set the data to arrary and concat it directly
        let tx_hash_data_encode_packed = [&target.to_vec(), &value.to_be_bytes_vec(), func.as_bytes(), &data.to_vec(), &timestamp.to_be_bytes_vec()].concat();
        // hash the encoded data
        self.keccak256(tx_hash_data_encode_packed.into())
    }


    // The func example: "transfer(address,uint256)"
    pub fn encode_with_signature(
        &self, 
        func: String, 
        address: Address, 
        amount: U256
    ) -> Vec<u8> {
        type TransferType = (SOLAddress, Uint<256>);
        let tx_data = (address, amount);
        let data = TransferType::abi_encode_sequence(&tx_data);
         // Get function selector
         let hashed_function_selector = self.keccak256(func.as_bytes().to_vec().into());
         // Combine function selector and input data (use abi_packed way)
         let calldata = [&hashed_function_selector[..4], &data].concat();
        calldata
    }

    // The func example: "transfer(address,uint256)"
    pub fn encode_with_signature_and_hash(
        &self, 
        func: String, 
        address: Address, 
        amount: U256
    ) -> FixedBytes<32> {
        type TransferType = (SOLAddress, Uint<256>);
        let tx_data = (address, amount);
        let data = TransferType::abi_encode_sequence(&tx_data);
         // Get function selector
         let hashed_function_selector = self.keccak256(func.as_bytes().to_vec().into());
         // Combine function selector and input data (use abi_packed way)
         let calldata = [&hashed_function_selector[..4], &data].concat();
         self.keccak256(calldata.into())
    }

}
```

### Cargo.toml

```rust
[package]
name = "stylus-encode-hashing"
version = "0.1.0"
edition = "2021"

[dependencies]
alloy-primitives = "0.7.3"
alloy-sol-types = "0.7.3"
mini-alloc = "0.4.2"
stylus-sdk = "0.5.1"
hex = "0.4.3"
sha3 = "0.10.8"

[features]
export-abi = ["stylus-sdk/export-abi"]
debug = ["stylus-sdk/debug"]

[lib]
crate-type = ["lib", "cdylib"]

[profile.release]
codegen-units = 1
strip = true
lto = true
panic = "abort"
opt-level = "s"

```