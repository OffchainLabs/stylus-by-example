export const metadata = {
  title: "Storage Data Types â€¢ Stylus by Example",
  description:
    'Defines the basic state variables used in Arbitrum Stylus Rust smart contracts and how they can be used to store and retrieve state from the VM.',
};

{/* Begin Content */}

# Storage Data Types in Stylus

The **Stylus SDK** provides a way to define state variables that are stored on the blockchain, similar but not the same to [how state define variables work in Solidity](https://solidity-by-example.org/state-variables/). These variables persist across contract calls and represent the contract's persistent storage.  In Stylus, you define these storage variables within a struct annotated with `#[storage]`.

In summary, state variables in the Rust SDK have the following types:

- `StorageBool`
- `StorageAddress`
- `StorageUint`
- `StorageSigned`
- `StorageFixedBytes`
- `StorageVec`
- `StorageString`
- `StorageBytes`
- `StorageMap`
- `StorageArray`

`StorageString` is essentially a wrapper around `StorageBytes`, providing convenient methods for working with UTF-8 encoded strings.  [`StorageMap`](https://stylus-by-example.org/basic_examples/mapping) and [`StorageArray`](https://stylus-by-example.org/basic_examples/arrays) will be discussed in separate sections due to their more complex nature.  This section focuses on the first seven types.


## Defining the Storage Struct

```rust
#![cfg_attr(not(any(feature = "export-abi", test)), no_main)]
extern crate alloc;

use stylus_sdk::{
    prelude::*,
    alloy_primitives::{I256, U256, Address, FixedBytes},
    storage::*,
};

#[storage]
#[entrypoint]
pub struct Data {
    my_bool: StorageBool,
    my_address: StorageAddress,
    my_uint: StorageU256,
    my_signed: StorageI256,
    my_fixed_bytes: StorageFixedBytes<4>,
    my_string: StorageString,
    my_vec: StorageVec<StorageU256>,
}

#[public]
impl Data {
    //... (Getters and Setters as shown below)
}
```

The `#[storage]` attribute on the `Data` struct tells Stylus that the fields within this struct represent the contract's state storage. The `#[entrypoint]` attribute indicates the contract's entry point.

## Storage Types

### StorageBool

`StorageBool` stores a boolean value (`true` or `false`).

```rust
//... inside the #[public] impl Data block

    #[storage]
    static mut my_bool: StorageBool = StorageType::new(); // Example initialization if needed

    pub fn get_bool(&self) -> bool {
        self.my_bool.get()
    }

    pub fn set_bool(&mut self, value: bool) {
        self.my_bool.set(value);
    }
```

### StorageAddress

`StorageAddress` stores an Ethereum address (`alloy_primitives::Address`).

```rust
//... inside the #[public] impl Data block

    #[storage]
    static mut my_address: StorageAddress = StorageType::new();

    pub fn get_address(&self) -> Address {
        self.my_address.get()
    }

    pub fn set_address(&mut self, value: Address) {
        self.my_address.set(value);
    }
```

### StorageU256

`StorageU256` stores an unsigned 256-bit integer (`alloy_primitives::U256`).

```rust
//... inside the #[public] impl Data block

    #[storage]
    static mut my_uint: StorageU256 = StorageType::new();

    pub fn get_uint(&self) -> U256 {
        self.my_uint.get()
    }

    pub fn set_uint(&mut self, value: U256) {
        self.my_uint.set(value);
    }
```

`StorageU256` is an alias of `StorageUint`, you can also define `StorageU128` or other byte length uint.

### StorageI256

`StorageI256` stores a signed 256-bit integer (`alloy_primitives::I256`).

```rust
//... inside the #[public] impl Data block

    #[storage]
    static mut my_signed: StorageI256 = StorageType::new();

    pub fn get_signed(&self) -> I256 {
        self.my_signed.get()
    }

    pub fn set_signed(&mut self, value: I256) {
        self.my_signed.set(value);
    }
```

`StorageI256` is an alias of `StorageSigned`, you can also define `StorageI128` or other byte length int.

### StorageFixedBytes

`StorageFixedBytes<N>` stores a fixed-size byte array of `N` bytes (`alloy_primitives::FixedBytes<N>`).

```rust
//... inside the #[public] impl Data block

    #[storage]
    static mut my_fixed_bytes: StorageFixedBytes<4> = StorageType::new();

    pub fn get_fixed_bytes(&self) -> FixedBytes<4> {
        self.my_fixed_bytes.get()
    }

    pub fn set_fixed_bytes(&mut self, value: FixedBytes<4>) {
        self.my_fixed_bytes.set(value);
    }
```

### StorageBytes

`StorageBytes` stores a dynamic byte array (`Vec<u8>`).

```rust
//... inside the #[public] impl Data block

    #[storage]
    static mut my_bytes: StorageBytes = StorageType::new();

    pub fn get_bytes(&self) -> Vec<u8> {
        self.my_bytes.get()
    }

    pub fn set_bytes(&mut self, value: Vec<u8>) {
        self.my_bytes.set(value);
    }
```

### StorageString

`StorageString` stores a UTF-8 encoded string (`String`).

```rust
//... inside the #[public] impl Data block

    #[storage]
    static mut my_string: StorageString = StorageType::new();

    pub fn get_string(&self) -> String {
        self.my_string.get_string()
    }

    pub fn set_string(&mut self, value: String) {
        self.my_string.set_str(value);
    }
```

### StorageVec

`StorageVec<T>` stores a dynamically sized vector (array) of type `T` (`stylus_sdk::storage::StorageVec<T>`).

```rust
//... inside the #[public] impl Data block

    #[storage]
    static mut my_vec: StorageVec<StorageU256> = StorageType::new();

    pub fn get_vec(&self, index: U256) -> U256 {
        self.my_vec.get(index).unwrap() // Handle potential out-of-bounds access properly
    }

    pub fn push_vec(&mut self, value: U256) {
        self.my_vec.push(value);
    }
```

This structured format makes it easier to navigate and understand the different storage types available in Stylus.  
Each type has its own section with the relevant code snippets for getters and setters.  This organization is much clearer than grouping all the getters and setters together.  Remember to handle potential panics from `unwrap()` appropriately in your actual contract code.