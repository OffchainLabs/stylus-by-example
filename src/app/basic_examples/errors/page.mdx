export const metadata = {
  title: "Errors â€¢ Stylus by Example",
  description:
    "How to define and use Errors on Stylus Rust smart contracts",
};

{/* Begin Content */}

# Errors

In Rust Stylus contracts, error handling is a crucial aspect of writing robust and reliable smart contracts. Rust differentiates between recoverable and unrecoverable errors. Recoverable errors are represented using the `Result` type, which can either be `Ok`, indicating success, or `Err`, indicating failure. This allows developers to manage errors gracefully and maintain control over the flow of execution. Unrecoverable errors are handled with the `panic!` macro, which stops execution, unwinds the stack, and returns a dataless error. 

In Stylus contracts, error types are often explicitly defined, providing clear and structured ways to handle different failure scenarios. This structured approach promotes better error management, ensuring that contracts are secure, maintainable, and behave predictably under various conditions. Similar to Solidity and EVM, errors in Stylus will undo all changes made to the state during a transaction by reverting the transaction. Thus, there are two main types of errors in Rust Stylus contracts:

1. **Recoverable Errors**: The Stylus SDK provides features that make using recoverable errors in Rust Stylus contracts convenient. This type of error handling is recommended for Stylus contracts.
2. **Unrecoverable Errors**: These can be defined similarly to Rust code but are not recommended for smart contracts if recoverable errors can be used instead.

You can throw an error by calling `unwrap()`, `match`, `? Operator` and `custom errors`.

## Learn More

- [Solidity docs: Expressions and Control Structures](https://docs.soliditylang.org/en/latest/control-structures.html)
- [`#[derive(SolidityError)]`](https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/derive.SolidityError.html)
- [`alloy_sol_types::SolError`](https://docs.rs/alloy-sol-types/latest/alloy_sol_types/trait.SolError.html)
- [`Error handling: Rust book`](https://doc.rust-lang.org/book/ch09-00-error-handling.html)

### Recoverable Errors in Rust Stylus Contracts

In Rust Stylus contracts, handling recoverable errors is essential for writing reliable and maintainable smart contracts. Recoverable errors are represented using the `Result` type, which can either be `Ok`, indicating success, or `Err`, indicating failure. The Stylus SDK provides tools to define custom error types and manage recoverable errors effectively.

#### Simple Example

Here's a basic Rust Stylus contract to demonstrate defining and handling recoverable errors:

```rust
#![cfg_attr(not(feature = "export-abi"), no_main)]
extern crate alloc;
use stylus_sdk::{msg, prelude::*, alloy_primitives::{Address, U256}};
use alloy_sol_types::sol;

sol! {
    error InsufficientBalance(address from, uint256 available, uint256 required);
}

sol_storage! {
    #[entrypoint]
    pub struct SimpleWallet {
        mapping(address => uint256) balances;
    }
}

#[derive(SolidityError)]
pub enum WalletError {
    InsufficientBalance(InsufficientBalance),
}

#[external]
impl SimpleWallet {
    pub fn deposit(&mut self) {
        let sender = msg::sender();
        let amount = msg::value();
        let mut balance = self.balances.setter(sender);
        balance.set(balance.get() + amount);
    }

    pub fn withdraw(&mut self, amount: U256) -> Result<(), WalletError> {
        let sender = msg::sender();
        let mut balance = self.balances.setter(sender);
        if balance.get() < amount {
            return Err(WalletError::InsufficientBalance(InsufficientBalance {
                from: sender,
                available: balance.get(),
                required: amount,
            }));
        }
        balance.set(balance.get() - amount);
        Ok(())
    }

    pub fn get_balance(&self, address: Address) -> U256 {
        self.balances.get(address)
    }
}
```

### Explanation

1. **Defining Errors**: The custom error `InsufficientBalance` is defined using the `sol!` macro.
2. **Using `SolidityError` Derive Macro**: The `#[derive(SolidityError)]` attribute is used for the `WalletError` enum, automatically implementing the necessary traits for error handling.
5. **Withdrawals Error Handling**: The `withdraw` function checks if the user has sufficient funds before allowing withdrawal. If not, it returns an `InsufficientBalance` error with related arguments.

This brief example shows how to define and handle recoverable errors in a Rust Stylus contract using the Stylus SDK, making error management straightforward.


### Log Usage

```rust
// sol! macro event declaration
// Up to 3 parameters can be indexed.
// Indexed parameters helps you filter the logs efficiently
sol! {
    event Log(address indexed sender, string message);
    event AnotherLog();
}

#[entrypoint]
fn user_main(_input: Vec<u8>) -> ArbResult {
    // emits a 'Log' event, defined above in the sol! macro
    evm::log(Log {
        sender: Address::from([0x11; 20]),
        message: "Hello world!".to_string(),
    });

    // no data, but 'AnotherLog' event will still emit to the chain
    evm::log(AnotherLog {});

    Ok(vec![])
}
```

## Raw Log

The `evm::raw_log` affordance offers the ability to send anonymous events that do not necessarily conform to the Solidity ABI. Instead, up to four raw 32-byte indexed topics are published along with any arbitrary bytes appended as data.

**NOTE**: It's still possible to achieve Solidity ABI compatibility using this construct. To do so you'll have to manually compute the ABI signature for the event, [following the equation set in the Solidity docs](https://docs.soliditylang.org/en/v0.8.19/abi-spec.html#events). The result of that should be assigned to `TOPIC_0`, the first topic in the slice passed to `raw_log`.

### Raw Log Usage

```rust
// set up local variables
let user = Address::from([0x22; 20]);
let balance = U256::from(10_000_000);

// declare up to 4 topics
// topics must be of type FixedBytes<32>
let topics = &[user.into_word()];

// store non-indexed data in a byte Vec
let mut data: Vec<u8> = vec![];
// to_be_bytes means 'to big endian bytes'
data.extend_from_slice(balance.to_be_bytes::<32>().to_vec().as_slice());

// unwrap() here 'consumes' the Result
evm::raw_log(topics.as_slice(), data.as_ref()).unwrap();
```

## Result

Combining the above examples into the boiler plate provided below this section, deploying to a Stylus chain and then invoking the deployed contract will result in the following three events logged to the chain:

### logs

```json
[
  {
    "address": "0x6cf4a18ac8efd6b0b99d3200c4fb9609dd60d4b3",
    "topics": [
      "0x0738f4da267a110d810e6e89fc59e46be6de0c37b1d5cd559b267dc3688e74e0",
      "0x0000000000000000000000001111111111111111111111111111111111111111"
    ],
    "data": "0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000c48656c6c6f20776f726c64210000000000000000000000000000000000000000",
    "blockHash": "0xfef880025dc87b5ab4695a0e1a6955dd7603166ecba79ce0f503a568b2ec8940",
    "blockNumber": "0x94",
    "transactionHash": "0xc7318dae2164eb441fb80f5b869f844e3e97ae83c24a4639d46ec4d915a30818",
    "transactionIndex": "0x1",
    "logIndex": "0x0",
    "removed": false
  },
  {
    "address": "0x6cf4a18ac8efd6b0b99d3200c4fb9609dd60d4b3",
    "topics": [
      "0xfe1a3ad11e425db4b8e6af35d11c50118826a496df73006fc724cb27f2b99946"
    ],
    "data": "0x",
    "blockHash": "0xfef880025dc87b5ab4695a0e1a6955dd7603166ecba79ce0f503a568b2ec8940",
    "blockNumber": "0x94",
    "transactionHash": "0xc7318dae2164eb441fb80f5b869f844e3e97ae83c24a4639d46ec4d915a30818",
    "transactionIndex": "0x1",
    "logIndex": "0x1",
    "removed": false
  },
  {
    "address": "0x6cf4a18ac8efd6b0b99d3200c4fb9609dd60d4b3",
    "topics": [
      "0x0000000000000000000000002222222222222222222222222222222222222222"
    ],
    "data": "0x0000000000000000000000000000000000000000000000000000000000989680",
    "blockHash": "0xfef880025dc87b5ab4695a0e1a6955dd7603166ecba79ce0f503a568b2ec8940",
    "blockNumber": "0x94",
    "transactionHash": "0xc7318dae2164eb441fb80f5b869f844e3e97ae83c24a4639d46ec4d915a30818",
    "transactionIndex": "0x1",
    "logIndex": "0x2",
    "removed": false
  }
]
```

## Boilerplate

### src/main.rs

```rust
#![no_main]
#![no_std]
extern crate alloc;

#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;
use alloc::vec::Vec;
use alloc::{string::ToString, vec};

use stylus_sdk::alloy_primitives::{U256, Address};
use stylus_sdk::alloy_sol_types::sol;
use stylus_sdk::{evm, prelude::*, ArbResult};


#[entrypoint]
fn user_main(_input: Vec<u8>) -> ArbResult {
    // Insert logic from above usages here

    Ok(Vec::new())
}
```

### Cargo.toml

```toml
[package]
name = "events"
version = "0.1.0"
edition = "2021"

[dependencies]
# Note: Do not ship to prod with 'debug' flag set
stylus-sdk = { version = "0.4.2", features = ["debug"] }
wee_alloc = "0.4.5"
alloy-sol-types = "0.3.1"

[features]
export-abi = ["stylus-sdk/export-abi"]

[profile.release]
codegen-units = 1
strip = true
lto = true
panic = "abort"
opt-level = "s"

[workspace]

```
