export const metadata = {
  title: "Errors â€¢ Stylus by Example",
  description:
    "How to define and use Errors on Stylus Rust smart contracts",
};

{/* Begin Content */}

# Errors

In Rust Stylus contracts, error handling is a crucial aspect of writing robust and reliable smart contracts. Rust differentiates between recoverable and unrecoverable errors. Recoverable errors are represented using the `Result` type, which can either be `Ok`, indicating success, or `Err`, indicating failure. This allows developers to manage errors gracefully and maintain control over the flow of execution. Unrecoverable errors are handled with the `panic!` macro, which stops execution, unwinds the stack, and returns a dataless error. 

In Stylus contracts, error types are often explicitly defined, providing clear and structured ways to handle different failure scenarios. This structured approach promotes better error management, ensuring that contracts are secure, maintainable, and behave predictably under various conditions. Similar to Solidity and EVM, errors in Stylus will undo all changes made to the state during a transaction by reverting the transaction. Thus, there are two main types of errors in Rust Stylus contracts:

1. **Recoverable Errors**: The Stylus SDK provides features that make using recoverable errors in Rust Stylus contracts convenient. This type of error handling is recommended for Stylus contracts.
2. **Unrecoverable Errors**: These can be defined similarly to Rust code but are not recommended for smart contracts if recoverable errors can be used instead.

You can throw an error by calling `unwrap()`, `match`, `? Operator` and `custom errors`.

## Learn More

- [Solidity docs: Expressions and Control Structures](https://docs.soliditylang.org/en/latest/control-structures.html)
- [`#[derive(SolidityError)]`](https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/derive.SolidityError.html)
- [`alloy_sol_types::SolError`](https://docs.rs/alloy-sol-types/latest/alloy_sol_types/trait.SolError.html)
- [`Error handling: Rust book`](https://doc.rust-lang.org/book/ch09-00-error-handling.html)

### Recoverable Errors in Rust Stylus Contracts

In Rust Stylus contracts, handling recoverable errors is essential for writing reliable and maintainable smart contracts. Recoverable errors are represented using the `Result` type, which can either be `Ok`, indicating success, or `Err`, indicating failure. The Stylus SDK provides tools to define custom error types and manage recoverable errors effectively.

#### Simple Example

Here's a basic Rust Stylus contract to demonstrate defining and handling recoverable errors:

```rust
#![cfg_attr(not(feature = "export-abi"), no_main)]
extern crate alloc;
use stylus_sdk::{msg, prelude::*, alloy_primitives::{Address, U256}};
use alloy_sol_types::sol;

sol! {
    error InsufficientBalance(address from, uint256 available, uint256 required);
}

sol_storage! {
    #[entrypoint]
    pub struct SimpleWallet {
        mapping(address => uint256) balances;
    }
}

#[derive(SolidityError)]
pub enum WalletError {
    InsufficientBalance(InsufficientBalance),
}

#[external]
impl SimpleWallet {
    pub fn deposit(&mut self) {
        let sender = msg::sender();
        let amount = msg::value();
        let mut balance = self.balances.setter(sender);
        balance.set(balance.get() + amount);
    }

    pub fn withdraw(&mut self, amount: U256) -> Result<(), WalletError> {
        let sender = msg::sender();
        let mut balance = self.balances.setter(sender);
        if balance.get() < amount {
            return Err(WalletError::InsufficientBalance(InsufficientBalance {
                from: sender,
                available: balance.get(),
                required: amount,
            }));
        }
        balance.set(balance.get() - amount);
        Ok(())
    }

    pub fn get_balance(&self, address: Address) -> U256 {
        self.balances.get(address)
    }
}
```

### Explanation

1. **Defining Errors**: The custom error `InsufficientBalance` is defined using the `sol!` macro.
2. **Using `SolidityError` Derive Macro**: The `#[derive(SolidityError)]` attribute is used for the `WalletError` enum, automatically implementing the necessary traits for error handling.
5. **Withdrawals Error Handling**: The `withdraw` function checks if the user has sufficient funds before allowing withdrawal. If not, it returns an `InsufficientBalance` error with related arguments.

This brief example shows how to define and handle recoverable errors in a Rust Stylus contract using the Stylus SDK, making error management straightforward.

### Unrecoverable Errors in Rust Stylus Contracts

Unrecoverable errors in Rust Stylus contracts are handled using the `panic!` macro, which stops execution, unwinds the stack, and returns a dataless error. Here are various ways to handle such errors in the `withdraw` function:

#### Using `panic!`

Directly panics if the balance is insufficient.

```rust
pub fn withdraw(&mut self, amount: U256) {
    let sender = msg::sender();
    let mut balance = self.balances.setter(sender);
    if balance.get() < amount {
        panic!("Insufficient funds: available {}, required {}", balance.get(), amount);
    }
    balance.set(balance.get() - amount);
}
```

#### Using `unwrap`

Uses `unwrap` to get the balance, panicking if the balance is `None`.

```rust
pub fn withdraw(&mut self, amount: U256) {
    let sender = msg::sender();
    let mut balance = self.balances.setter(sender);
    let current_balance = balance.get();
    assert!(current_balance >= amount, "Insufficient funds: available {}, required {}", current_balance, amount);
    balance.set(current_balance - amount);
}
```

#### Using `expect`

Uses `expect` to get the balance, panicking with a custom message if the balance is `None`.

```rust
pub fn withdraw(&mut self, amount: U256) {
    let sender = msg::sender();
    let mut balance = self.balances.setter(sender);
    let current_balance = balance.get();
    if current_balance < amount {
        panic!("Insufficient funds: available {}, required {}", current_balance, amount);
    }
    balance.set(current_balance - amount);
}
```

#### Using `match`

Uses a `match` statement to handle the result of `checked_sub`, panicking if the subtraction would result in an overflow.

```rust
pub fn withdraw(&mut self, amount: U256) {
    let sender = msg::sender();
    let mut balance = self.balances.setter(sender);
    match balance.get().checked_sub(amount) {
        Some(new_balance) => balance.set(new_balance),
        None => panic!("Insufficient funds: available {}, required {}", balance.get(), amount),
    }
}
```

#### Using `ok_or_else` and `unwrap`

Combines `ok_or_else` to provide a custom panic message if the condition fails and `unwrap` to handle the result.

```rust
pub fn withdraw(&mut self, amount: U256) {
    let sender = msg::sender();
    let mut balance = self.balances.setter(sender);
    balance.get().checked_sub(amount).ok_or_else(|| {
        panic!("Insufficient funds: available {}, required {}", balance.get(), amount)
    }).unwrap();
    balance.set(balance.get() - amount);
}
```

Each method demonstrates a different way to handle unrecoverable errors in the `withdraw` function of a Rust Stylus contract.