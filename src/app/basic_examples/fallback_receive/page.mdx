export const metadata = {
  title: "Fallback and Receive- Stylus by Example",
  description:
    "Learn how to use the Fallback and Receive functions in Stylus smart contracts.",
};

{/* Begin Content */}
# Fallback and Receive Functions in Stylus

In Stylus smart contracts, `fallback` and `receive` functions are special functions that handle incoming transactions when no other function matches the call signature. These functions are crucial for creating flexible contracts that can handle various types of interactions, including direct Ether transfers and unknown function calls.

## Understanding the Difference

### Receive Function
The `receive` function is specifically designed to handle **plain Ether transfers** - transactions that send Ether to your contract without any calldata.

**Key characteristics:**
- Called when a transaction has **no calldata** (empty data field)
- Takes no inputs and returns no outputs
- Optional - if not defined, plain Ether transfers will trigger the fallback function
- Has higher priority than fallback when both are defined

### Fallback Function
The `fallback` function is a catch-all handler for transactions that don't match any existing function signature.

**Key characteristics:**
- Called when no function signature matches the transaction's calldata
- Also called for plain Ether transfers if no `receive` function is defined
- Can be `payable` or non-payable
- Can access the calldata that was sent with the transaction
- If not defined, unmatched calls will revert

## Function Call Priority

When a transaction is sent to your contract, Stylus follows this decision tree:

1. **Has calldata?**
   - No → Call `receive()` (if defined), otherwise call `fallback()`
   - Yes → Try to match a function signature
2. **Function signature matches?**
   - Yes → Call the matching function
   - No → Call `fallback()` (if defined), otherwise revert

## Complete Working Example

Here's a comprehensive example that demonstrates both functions with full testing. The tests demonstrate how to verify that the correct events are emitted. In the ```receive``` function, we track the total Ether received, the number of times the receive function is called, and emits events on the receive function. 
The `receive` function updates the sender's balance and logs the event with the method name "receive".

The `fallback` function tracks the total Ether received, the number of times it is called on fallback method, and emits events for both Ether transfers and unknown function calls. It also updates the sender's balance and logs the calldata if available. In the testing part we test if each part of receive and fallback functions are working correctly, including the event emissions and balance updates.


### src/lib.rs

```rust
#![cfg_attr(not(feature = "export-abi"), no_std)]
extern crate alloc;

use stylus_sdk::alloy_sol_types::sol;
use stylus_sdk::{
    alloy_primitives::{U256, Address, FixedBytes},
    ArbResult,
    prelude::*,
};
use alloc::vec;
use crate::alloc::string::ToString;
use crate::vec::Vec;
// Define persistent storage
sol_storage! {
    #[entrypoint]
    pub struct PaymentTracker {
        uint256 total_received;
        uint256 fallback_calls;
        uint256 receive_calls;
        mapping(address => uint256) balances;
    }
}

// Define events for better tracking
sol! {
    event EtherReceived(address indexed sender, uint256 amount, string method);
    event FallbackTriggered(address indexed sender, uint256 amount, bytes data);
    event UnknownFunctionCalled(address indexed sender, bytes4 selector);
}

#[public]
impl PaymentTracker {
    // Regular function to check balance
    pub fn get_balance(&mut self, account: Address) {
        self.balances.setter(account).set(U256::from(1));
        self.total_received.get();        
    }
    
    // Regular function to get statistics
    pub fn get_stats(&self) -> (U256, U256, U256) {
        (
            self.total_received.get(),
            self.receive_calls.get(),
            self.fallback_calls.get()
        )
    }

    /// Receive function - handles plain Ether transfers
    /// This is called when someone sends Ether without any data
    /// Example: contract.send(1 ether) or contract.transfer(1 ether)
    #[receive]
    #[payable]
    pub fn receive(&mut self) -> Result<(), Vec<u8>> {
        let sender = self.vm().msg_sender();
        let amount = self.vm().msg_value();
        
        // Update tracking variables
        self.total_received.set(self.total_received.get() + amount);
        self.receive_calls.set(self.receive_calls.get() + U256::from(1));
        
        // Update sender's balance using setter method
        let current_balance = self.balances.get(sender);
        self.balances.setter(sender).set(current_balance + amount);
        
        // Log the event
        stylus_sdk::stylus_core::log(
            self.vm(),
            EtherReceived {
                sender,
                amount,
                method: "receive".to_string(),
            },
        );
        
        Ok(())
    }

    /// Fallback function - handles unmatched function calls
    /// This is called when:
    /// 1. A function call doesn't match any existing function signature
    /// 2. Plain Ether transfer when no receive function exists
    #[fallback]
    #[payable]
    pub fn fallback(&mut self, calldata: &[u8]) -> ArbResult {
        let sender = self.vm().msg_sender();
        let amount = self.vm().msg_value();
        
        // Update tracking
        self.fallback_calls.set(self.fallback_calls.get() + U256::from(1));
        
        if amount > U256::ZERO {
            // If Ether was sent, track it
            self.total_received.set(self.total_received.get() + amount);
            let current_balance = self.balances.get(sender);
            self.balances.setter(sender).set(current_balance + amount);
            
            stylus_sdk::stylus_core::log(
                self.vm(),
                EtherReceived {
                    sender,
                    amount,
                    method: "fallback".to_string(),
                },
            );
        }
        
        // Log the fallback trigger with calldata - convert to bytes properly
        stylus_sdk::stylus_core::log(
            self.vm(),
            FallbackTriggered {
                sender,
                amount,
                data: calldata.to_vec().into(),
            },
        );
        
        // If calldata has at least 4 bytes, extract the function selector
        if calldata.len() >= 4 {
            let selector = [calldata[0], calldata[1], calldata[2], calldata[3]];
            stylus_sdk::stylus_core::log(
                self.vm(),
                UnknownFunctionCalled {
                    sender,
                    selector: FixedBytes(selector),
                },
            );
        }
        
        // Return empty bytes (successful execution)
        Ok(vec![])
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use stylus_sdk::testing::*;
    use stylus_sdk::alloy_primitives::{B256, keccak256};

    #[test]
    fn test_receive_function() {
        let vm = TestVM::default();
        let mut contract = PaymentTracker::from(&vm);
        
        // Test that contract is created successfully and initial values are correct
        let (total, receive_calls, fallback_calls) = contract.get_stats();
        assert_eq!(total, U256::from(0));
        assert_eq!(receive_calls, U256::from(0));
        assert_eq!(fallback_calls, U256::from(0));
        // Override the msg value for future contract method invocations.
        vm.set_value(U256::from(2));
        let _ = contract.receive();
        // Check that the receive function updates stats correctly
        let (total, receive_calls, fallback_calls) = contract.get_stats();
        assert_eq!(total, U256::from(2));
        assert_eq!(receive_calls, U256::from(1));
        assert_eq!(fallback_calls, U256::from(0));
        // Check that the balance is updated
        let balance = contract.balances.get(vm.msg_sender());
        assert_eq!(balance, U256::from(2));
    }

    #[test]    
    fn test_fallback_function() {
        let vm = TestVM::default();
        let mut contract = PaymentTracker::from(&vm);
        
        // Test that contract is created successfully and initial values are correct
        let (total, receive_calls, fallback_calls) = contract.get_stats();
        assert_eq!(total, U256::from(0));
        assert_eq!(receive_calls, U256::from(0));
        assert_eq!(fallback_calls, U256::from(0));
        // Call the fallback function with some data
        let calldata = vec![0x01, 0x02, 0x03, 0x04];
        let _ = contract.fallback(&calldata);
        // Check that the fallback function updates stats correctly
        let (total, receive_calls, fallback_calls) = contract.get_stats();
        assert_eq!(total, U256::from(0));
        assert_eq!(receive_calls, U256::from(0));
        assert_eq!(fallback_calls, U256::from(1));
        // Check that the balance is updated
        let balance = contract.balances.get(vm.msg_sender());
        assert_eq!(balance, U256::from(0));

        // Check that the fallback triggered event was logged
        let logs = vm.get_emitted_logs();
        assert_eq!(logs.len(), 2);

        // Check that the first log is the FallbackTriggered event
        let event_signature = B256::from(keccak256(
            "FallbackTriggered(address,uint256,bytes)".as_bytes()
        ));
        assert_eq!(logs[0].0[0], event_signature);
        // Check that the second log is the UnknownFunctionCalled event
        let unknown_signature = B256::from(keccak256(
            "UnknownFunctionCalled(address,bytes4)".as_bytes()
        ));
        assert_eq!(logs[1].0[0], unknown_signature);
       
    }

    #[test]    
    fn test_fallback_function_with_value() {
        let vm = TestVM::default();
        let mut contract = PaymentTracker::from(&vm);
        
        // Test that contract is created successfully and initial values are correct
        let (total, receive_calls, fallback_calls) = contract.get_stats();
        assert_eq!(total, U256::from(0));
        assert_eq!(receive_calls, U256::from(0));
        assert_eq!(fallback_calls, U256::from(0));

        vm.set_value(U256::from(2));
        let calldata = vec![0x01, 0x02, 0x03, 0x04];
        // Call the fallback function with calldata and value
        let _ = contract.fallback(&calldata);
        // Check that the fallback function updates stats correctly
        let (total, receive_calls, fallback_calls) = contract.get_stats();
        assert_eq!(total, U256::from(2));
        assert_eq!(receive_calls, U256::from(0));
        assert_eq!(fallback_calls, U256::from(1));
        // Check that the balance is updated
        let balance = contract.balances.get(vm.msg_sender());
        assert_eq!(balance, U256::from(2));
        // Check that the fallback triggered event was logged
        let logs = vm.get_emitted_logs();
        assert_eq!(logs.len(), 3);
        // Check that the first log is the FallbackTriggered event
        let event_signature = B256::from(keccak256(
            "EtherReceived(address,uint256,string)".as_bytes()
        ));
        assert_eq!(logs[0].0[0], event_signature);
        // Check that the second log is the EtherReceived event
        let ether_received_signature = B256::from(keccak256(
            "FallbackTriggered(address,uint256,bytes)".as_bytes()
        ));
        assert_eq!(logs[1].0[0], ether_received_signature);
        // Check that the third log is the UnknownFunctionCalled event
        let unknown_signature = B256::from(keccak256(
            "UnknownFunctionCalled(address,bytes4)".as_bytes()
        ));
        assert_eq!(logs[2].0[0], unknown_signature);
    }
}
```

### Cargo.toml

```toml
[package]
name = "stylus_fallback_test"
version = "0.1.11"
edition = "2021"
license = "MIT OR Apache-2.0"
homepage = "https://github.com/OffchainLabs/stylus-hello-world"
repository = "https://github.com/OffchainLabs/stylus-hello-world"
keywords = ["arbitrum", "ethereum", "stylus", "alloy"]
description = "Stylus hello world example"

[dependencies]
alloy-primitives = "=0.8.20"
alloy-sol-types = "=0.8.20"
mini-alloc = "0.9.0"
stylus-sdk = "0.9.0"
hex = "0.4.3"
dotenv = "0.15.0"

[dev-dependencies]
alloy-primitives = { version = "=0.8.20", features = ["sha3-keccak"] }
tokio = { version = "1.12.0", features = ["full"] }
ethers = "2.0"
eyre = "0.6.8"
stylus-sdk = { version = "0.9.0", features = ["stylus-test"] }

[features]
export-abi = ["stylus-sdk/export-abi"]
debug = ["stylus-sdk/debug"]

[[bin]]
name = "stylus-hello-world"
path = "src/main.rs"

[lib]
crate-type = ["lib", "cdylib"]

[profile.release]
codegen-units = 1
strip = true
lto = true
panic = "abort"

# If you need to reduce the binary size, it is advisable to try other
# optimization levels, such as "s" and "z"
opt-level = 3
```

### src/main.rs

```rust
#![cfg_attr(not(any(test, feature = "export-abi")), no_main)]

#[cfg(not(any(test, feature = "export-abi")))]
#[no_mangle]
pub extern "C" fn main() {}

#[cfg(feature = "export-abi")]
fn main() {
    stylus_fallback_test::print_from_args();
}
```